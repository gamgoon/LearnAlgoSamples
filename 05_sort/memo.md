#버블정렬 Bubble sort
- 정렬 대상을 하나씩 줄여나간다.
- 집합의 범위를 n개, n-1 만큼 반복 (순회)
- 비교 횟수 : *n*(*n*-1)/2

#삽입 정렬 Insertion sort
- 정렬 대상을 하나씩 늘려나가는 방식
- 비교 횟수 : 최악 *n*(*n*-1)/2 , 최선 *n*-1 , 평균 (*n*^2^+n-2)/2
- 평균적으로는 삽입 정렬이 버블 정렬보다 더 나은 성능을 보인다.

#퀵 정렬 Quick Sort
- 퀵 정렬의 재귀 호출 깊이 (반복 횟수 대신)
- 데이터 집합을 나누기 위해 필요한 비교 횟수
- 최선의 경우
	- 데이터 집합의 크기가 *n*개일 때, 퀵정렬의 재귀호출 깊이는 log~2~*n* 이다.
	- 재귀 호출의 단계마다 수행하는 비교 횟수는 *n* 회
	- 이상적인 경우의 퀵 정렬의 비교 횟수 = 재귀 호출의 깊이 x 각 재귀 호출 단계에서의 비교 횟수 = *n* x log~2~*n* = *n* log~2~*n*
- 최악의 경우
	- 재귀 호출의 깊이 *n*-1
	- 매 재귀 호출마다 정렬 대상의 범위도 1씩 줄어든다.
	- 총 비교 횟수 = (n-1) + (n-2) + (n-3) + ... + 3 + 2 + 1 = n * (n-1)/2 = n(n-1)/2
	- 최악의 경우 버블,삽입 정렬의 성능과 비슷해진다.
- 최선, 최악의 경우는 드물다.
- 평균의 경우
	- 1.39*n*log~2~*n* : 최선의 경우에 비해 39%정도 느린 것.
- C 표준 라이브러리의 퀵 정렬 함수 : qsort()

# 참고 링크
- [memmove() 메모리 영역 복사, 자기 영역도 가능](http://forum.falinux.com/zbxe/index.php?document_srl=408167&mid=C_LIB)

- [포인터와 const 키워드](http://proneer.tistory.com/entry/C%EC%96%B8%EC%96%B4-%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%99%80-const-%ED%82%A4%EC%9B%8C%EB%93%9C)