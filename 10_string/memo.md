#문자열 검색
##고지식한 검색 Native Search
- 무식한 검색 Brute Force Search
- 최악의 경우 N(본문의 길이) * M(패턴의 길이)

##카프-라빈 알고리즘 
- 카프 Richard M.Karp, 라빈 Michael O, Rabin
- 해시 값을 활용한 문자열 검색
- 패턴 내의 문자들을 일일이 비교하는 대신에 패턴의 해시 값과 본문 안에 있는 하위 문자열의 해시 값만 비교.
- 해시 함수 : S는 문자열, S[n]은 문자열 내의 n번째 문자, m은 문자열의 길이
H~i~=S[i]*2^(m-1)^+S[i+1]*2^(m-2)^+ ... +S[i+m-2]*2^1^+S[i+m-1]*2^0^
- 해시 함수의 비용을 획기적으로 줄임
- 원래 해시 함수로는 비교할 때마다 매번 패턴의 길이 m만큼 문자에 접근해야 하지만, 새 해시 함수를 이용하면 항상 2개의 문자에만 접근하면 된다.
- 총 탐색 시간이 패턴의 길이와 상관없이 본문의 길이에만 영향을 받게 되어 탐색 성능이 훨씬 향상.
- 다만 해시 함수는 i 가 0일때, 즉 이전 해시 값이 미리 구해지지 않은 경우에는 사용할 수 없으므로 최초의 해시 값을 구할 때는 기존의 해시 함수를 사용.
- 문자열의 길이가 늘어나면 해시값도 따라 커지므로 일정 범위 안에 가둘 필요가 있는데, 이를 위해 함수의 결과를 어느 값으로 나눈 나머지를 해시 값으로 사용.

##KMP 알고리즘
- KMP (Knuth-Morris-Pratt)
- 고지식한 알고리즘처럼 본문의 왼쪽부터 시작해서 오른쪽으로 옮겨가며 문자를 직접 비교하는 방식.
- 하지만, 비교할 필요가 없는 부분은 지나치고, 비교가 필요한 부분만 비교를 수행한다.
- 참고 : [http://blog.naver.com/choyi0521/80206821567](http://blog.naver.com/choyi0521/80206821567)
###접두부, 접미부, 그리고 경계
- 어느 문자열이든 접두부(Prefix)와 접미부(Suffix)를 갖고 있다. 
- 빈 문자열이나 문자열에서 일치하는 접두부와 접미부 쌍을 가리켜 경계(Boarder)라고 한다. 
- 검색 수행 전에 미리 패턴으로부터 경계의 정보를 갖는 테이블을 만든다.

##보이어-무어 알고리즘 Boyer-Moore
- 오른쪽에서 왼쪽으로 비교, 이동은 왼쪽에서 오른쪽으로
- 패턴의 가장 오른쪽 문자가 불일치하면서 그 문자가 패턴내에 존재하지 않는다면 패턴의 길이만큼 검색 위치를 이동시킨다.
- 두가지 종류의 이동
	- 나쁜 문자 이동 Bad Character Shift
	- 착한 접미부 이동 Good Suffix Shift
###나쁜 문자 이동
- 단계
	1. 패턴에서 나쁜 문자를 찾는다
	2. 찾아낸 패턴의 나쁜 문자의 위치가 본문의 나쁜 문자 위치와 일치하게 패턴을 이동시킨다.

###착한 접미부 이동
- 패턴을 오른쪽에서부터 비교하기 때문에 패턴에는 본문과 일치하는 접미부가 나타난다.
- 두가지 상황
	1. 불일치가 일어났을 떄 착한 접미부와 동일한 문자열이 패턴의 착한 접미부 왼쪽에 존재하는 경우. 본문의 착한 접미부의 위치에 일치하도록 이동.
	2. 착한 접미부가 패턴 안에 존재하지 않지만, 착한 접미부의 접미부가 패턴의 접두부와 일치하는 때. 

###전처리 과정
- 나쁜 문자 이동 테이블 만들기
	- 패턴을 왼쪽에서 오른쪽으로 읽어나가면서 패턴에 있는 각 문자의 위치를 이 테이블에 기록.
	- 패턴안에 중복되는 문자들이 있어도 가장 오른쪽에 있는 문자의 위치만 테이블에 남게된다.
- 착한 접미부 이동 테이블 만들기
	- 착한 접미부의 이동 거리를 보관
	- .... 여기서 좌절;;;
