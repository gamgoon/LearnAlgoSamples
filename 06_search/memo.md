#Search
##순차 탐색 Sequential Search
- 선형 탐색 Linear Search 이라고 부르기도 한다.
- 처음부터 끝까지 모든 요소를 검사
- 비효율
- 정렬되지 않은 데이터 집합 속에서 원하는 데이터를 찾을 수 있는 유일한 방법
- 높은 성능을 필요로 하지 않거나 데이터 집합의 크기가 작은 곳에 사용.

###자기 구성 순차 탐색 Self-Organizing Sequential Search
- 자주 사용되는 항목을 데이터 집합의 앞쪽에 배치함으로써 순차 탐색의 검색 효율을 끌어올리는 방법
- 자주 사용되는 항목을 어떻게 선별하는가
	- 전진 이동법(Move To Front)
	- 전위법(Transpose)
	- 빈도 계수법(Frequency Count)

####전진 이동법
- 한번 탐색된 항목을 데이터 집합의 가장 앞에 위치시킴.
- 한번 찾은 항목을 연이어 또 찾는 경우 단번에 탐색 완료.
- 한번 탐색된 항목이 곧 이어서 또 다시 검색될 가능성이 높은 데이터 집합에서만 사용

####전위법
- 탐색된 항목을 바로 이전 항목과 교환
- *자주* 탐색된 항목을 점진적으로 앞으로 옮긴다.

####계수법
- 데이터 집합 내의 각 요소들이 탐색된 횟수를 별도의 공간에 저장.
- 탐색된 횟수가 높은 순으로 데이터 집합을 재구성하는 전략.
- 전위법은 가장 뒤에 있는 데이터가 가장 많은 선택을 받더라도 데이터 집합의 크기가 크면 가장 앞에 올 수 있다는 보장을 받을 순 없다.
- 계수 결과를 저장하는 별도의 공간을 유지해야 하고 계수 결과에 따라 데이터 집합을 재배치해야 하는 비용이 소요됨

##이진 탐색 Binary Search
- 정렬된 데이터 집합에서 사용할 수 있는 *고속* 탐색 알고리즘
- 탐색 범위를 1/2씩 줄여나가는 방식
- 데이터 집합이 배열인 경우에만 사용. => 동적으로 크기가 달라지는 데이터 집합에는 이진 탐색 트리 이용
- c표준 라이브러리의 이진 탐색 함수 : bsearch()

###성능 측정
- 데이터 집합의 크기를 n , 탐색 반복 횟수를 x 라고 한다면, 마지막 데이터 범위의 크기 1은 n 에 1/2의 x제곱을 곱한 값과 같다.

$$1 = n * (1/2)^x$$
$$1 = n * 1/2^x$$
$$2^x = n$$
$$x = log_2n$$

##이진 탐색 트리 Binary Search Tree
- 각 노드는 *왼쪽 자식 노드는 나보다 작고, 오른쪽 자식 노드는 나보다 크다.* 는 규칙을 따른다.
- 노드 삭제
	- 삭제 대상 노드의  자식 노드가 있는 경우
		- 양쪽 자식 노드를 모두 갖고 있는경우
			- 삭제된 노드의 오른쪽 하위 트리에서 가장 작은 값을 가진 노드(최소값 노드)를 삭제된 노드의 위치에 옮겨 놓는다.
			- 옮겨 놓은 '최소값 노드'가 자식이 있는 경우
				- 최소값 노드는 오른쪽 자식만 있으므로, 이 오른쪽 자식을 최소값 노드의 원래 부모에게 연결해준다.
		- 왼쪽 또는 오른쪽 중 어느 한쪽 노드만 갖고 있는 경우
			- 삭제되는 노드의 자식을 삭제되는 노드의 부모에게 연결
