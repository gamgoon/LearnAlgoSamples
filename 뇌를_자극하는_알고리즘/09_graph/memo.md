#그래프
##정의
- '정점의 모음'과 이 정점을 잇는 '간선의 모음'과의 결합
` 정점의 집합을 V, 간선의 집합을 E, 그리고 그래프를 G라고 했을 떄, G = (V, E)이다 `
##그래프의 표현
- 간선, 즉 정점과 정점의 인접 관계를 어떻게 나타내는가?
- 정점 사이의 인접 관계를 나타내는 방법
	- 인접 행렬 Adjacency Matrix
	- 인접 리스트 Adjacency List

###인접 행렬
- 정점의 수 N, N x N 크기의 행렬을 만들어 행렬의 각 원소를 한 정점과 또 다른 정점이 인접해 있는 경우 1, 인접해 있지 않은 경우 0으로 표시
- 무방향성 그래프의 경우는 인접 행렬은 주 대각선에 대해 대칭을 이루는 특징.
- 정점 간의 인접여부를 쉽게 알수 있는 장점
- 메모리의 양이 커지는 단점
- 그래프 내의 정점의 수가 많지 않고 정점끼리의 인접 여부를 빠르게 알아내야 할 때

###인접 리스트
- 각 정점의 인접 정점들의 목록을 리스트로 연결.
- 정점과 간선의 삽입이 빠르고 인접 관계를 표시하는 리스트에 사용되는 메모리 양이 적다는 장점
- 순차 탐색을 해야하는 단점.
- 정점과 간선의 입력이 빈번하고 메모리 효율성을 우선시 해야할 때 

##그래프 순회
- 너비 우선 탐색 : 최단 경로를 찾는 알고리즘을 익힐 수 있음
- 깊이 우선 탐색 : 그래프를 정렬하는 알고리즘을 익힐 수 있음

###깊이 우선 탐색 Depth First Search
- 더 나아갈 길이 보이지 않ㅇ르 때까지 깊이 들어간다
- 미로 찾기
- 동작방식
	1. 시작 정점을 밟은 후 이 정점을 '방문했음'으로 표시
	2. 그리고 이 정점과 이웃하고 있는 정점(즉, 인접 정점) 중에 아직 방문하지 않은 곳을 선택하여 이를 시작 정점으로 삼아 다시 깊이 우선 탐색을 시작합니다. 그러니까 단계 1을 다시 하는 것.
	3. 정점에 더 이상 방문하지 않은 인접 정점이 없으면 이전 정점으로 돌아가서 단계 2를 수행.
	4. 이전 정점으로 돌아가도 더 이상 방문할 이웃이 없다면 그래프의 모든 정점을 모두 방문했다는 뜻. 탐색 종료.

###너비 우선 탐색 Breadth First Search
- 꼼꼼하게 좌우를 살피며 다니자.
- 깊이 우선 탐색과 방문하는 정점의 순서가 다름
- 동작방식
	1. 시작 정점을 '방문했음'으로 표시하고 큐에 삽입(Enqueue)합니다.
	2. 큐로부터 정점을 제거(Dequeue)합니다. 제거한 정점이 이웃하고 있는 인접 정점 중 아직 방문하지 않은 곳들을 '방문했음'으로 표시하고 큐에 삽입합니다.
	3. 큐가 비게 되면 탐색이 끝난 것입니다. 따라서 큐가 빌 때까지 2의 과정을 반복

##위상 정렬 Topological Sort
- 위상 : 어떤 사물이 다른 사물과의 관계 속에서 가지는 위치나 상태
` 어떤 정점이 다른 정점과의 관계 속에서 가지는 위치 `
- 필수조건
	1. 방향성이 있어야한다.
	2. 사이클이 없어야 한다.
	- 이런 그래프를 DAG (Directed Acyclic Graph) 라 한다.
- 정점의 두가지 종류의 방향성 간선을 가진다.
	- 정점으로 들어가는 진입 간선 Incoming Edge
	- 진출 간선 Outgoing Edge
- 정렬 과정
	1. 리스트를 하나 준비한다.
	2. 그래프에서 진입 간선이 없는 정점을 리스트에 추가하고, 해당 정점 자신과 진출 간선을 제거한다.
	3. 모든 정점에 대해 2를 반복하고 그래프 내에 정점이 남아 있지 않으면 정렬을 종료한다. 이때 리스트에는 위상 정렬된 그래프가 저장된다.
- 깊이 우선 탐색을 이용한 위상 정렬 과정
	1. 리스트를 준비
	2. 진입 간선이 없는 정점에 대해 깊이 우선 탐색을 시행하고, 탐색 중에 더 이상 옮겨갈 수 있는 인접 정점이 없는 정점을 만나면 이 정점을 리스트의 새로운 '헤드'로 입력 합니다.
	3. 2를 반복하다가 더 이상 방문할 정점이 없으면 깊이 우선 탐색을 종료. 깊이 우선 탐색이 끝난 후 리스트에는 위상 정렬된 그래프가 남는다.

##가중치 Weight
- 예 : 지도상의 도시를 정점으로 표시하고 도시간의 도로를 간선으로 표시한 다음, 도시 간의 거리를 가중치로 표현할 수 있음.

##신장 트리 Spanning Tree
- 신장 Spanning : 떨어져 있는 둘 사이를 다리 등으로 연결한다는 뜻
- 그래프의 모든 정점을 연결 하는 트리.
- 그래프의 하위 개념
- 트리? : 그래프는 사이클을 형성하는 간선만 제거하면 트리로 변신.

##최소 신장 트리 Minimum Spanning Tree
- 최소 가중치 신장 트리
- 각 간선이 갖고 있는 가중치의 합이 최소가 되는 신장 트리
- 사용되는 알고리즘
	- 프림 알고리즘 Prim's Algorithm
	- 크루스칼 알고리즘 Kruskal's Algorithm

###프림 알고리즘
- 최소 신장 트리를 만들어내는 과정
	1. 그래프와 최소 신장 트리를 준비. 물론 이때의 최소 신장 트리는 노드가 하나도 없는 상태.
	2. 그래프에서 임의의 정점을 시작 정점으로 선택하여 최소 신장 트리의 루트 노드로 삽입한다.
	3. 최소 신장 트리에 삽입되어 있는 정점들과 이 정점들의 모든 인접 정점 사이에 있는 간선의 가중치를 조사한다. 간선 중에 가장 가중치가 작은 것을 골라 이 간선에 연결되어 있는 인접 정점을 최소 신장 트리에 삽입한다. 단, 새로 삽입되는 정점은 최소 신장 트리에 삽입되어 있는 기존의 노드들과 사이클을 형성해서는 안된다.
	4. 3의 과정을 반복하다가 최소 신장 트리가 그래프의 모든 정점을 연결하게 되면 알고리즘을 종료.

###크루스칼 알고리즘 Kruskal's Algorithm
- 그래프 내의 모든 간선들의 가중치 정보를 사전에 파악하고 이 정보를 토대로 최소 신장 트리를 구축.
- 과정
	1. 그래프 내의 모든 간선을 가중치의 오름차순으로 목록을 만든다.
	2. 1에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장 트리에 추가한다. 단, 이때 추가된 간선으로 인해 최소 신장 트리내에 사이클이 형성되면 안된다.
- 사이클을 어떻게 효율적으로 감지할 것인가?
- 탐색 비용이 크다.
	- 사이클 탐지 방법 : 분리 집합
		- 각 정점들을 각각의 집합 안에 입력하고, 간선으로 연결되어 있는 정점들에 대해서는 합집합을 수행. 이때 간선으로 연결할 두 정점이 같은 집합에 속해 있다면 이 연결은 사이클을 이루게 된다. 

##최단 경로 탐색
- 그래프 내의 한 정점에서 다른 정점으로 이동할 때 가중치 합이 최소값이 되게 만드는 경로를 찾는 알고리즘

### 다익스트라 알고리즘 Edsger Dijkstra
- 프림 알고리즘과 동작 방식이 비슷. 프림 알고리즘은 단순히 간선의 길이를 이용해 어떤 간선을 먼저 연결할지를 결정하는데 반해, 다익스트라 알고리즘은 '경로의 길이'를 감안해서 간선을 연결한다.
- 사이클이 없는 방향성 그래프에 한해서만 사용할 수 있다.
- 동작 순서
	1. 각 정점 위에 시작점으로부터 자신에게 이르는 경로의 길이를 저장할 곳을 진비하고 모든 정점 위에 있는 경로의 길이를 무한대로 초기화 한다.
	2. 시작 정점의 경로 길이를 0으로 초기화하고(시작 정점에서 시작정점까지의 거리는 0) 최단 경로에 추가한다.
	3. 최단 경로에 새로 추가된 정점의 인접 정점들에 대해 경로 길이를 갱신하고 이들을 최단 경로에 추가한다. 만약 추가하려는 인접 정점이 이미 최단 경로 안에 존재한다면 갱신되기 이전의 경로 길이가 새로운 경로의 길이보다 더 큰 경우에 한해, 다른 선행 정점을 지나던 기존의 경로를 현재 정점을 경유하도록 수정한다.
	4. 그래프 내의 모든 정점이 최단 경로에 소속될 떄까지 3과정을 반복한다.

